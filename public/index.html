<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Words — тренажёр</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; line-height: 1.4; max-width: 820px; margin: 24px auto; padding: 0 16px; }
    h1,h2 { margin: 16px 0 8px; }
    table { border-collapse: collapse; width: 100%; margin-top: 8px; }
    th, td { border: 1px solid #ccc; padding: 6px 8px; text-align: left; }
    #feedback { font-weight: 600; margin: 8px 0 4px; }
    #interval { color: #666; margin: 0 0 8px; }
    input[type="text"]{ padding: 6px 8px; }
    button{ padding: 6px 10px; cursor:pointer; }
  </style>
</head>
<body>

  <h1>Вход / Регистрация</h1>
  <div id="auth">
    <form id="authForm" onsubmit="event.preventDefault(); document.getElementById('login').click();">
      <input type="email" id="email" placeholder="Email" autocomplete="username" />
      <input type="password" id="password" placeholder="Пароль" autocomplete="current-password" />
      <button id="login" type="button">Войти</button>
      <button id="register" type="button">Регистрация</button>
    </form>
    <p id="authStatus" style="font-weight:600;"></p>
  </div>
  <p id="loggedIn" style="display:none;">Вы вошли как <span id="userEmail"></span> <button id="logout">Выйти</button></p>
  <hr/>

  <h1>Добавить слово</h1>
  <form id="addForm">
    <input type="text" name="de" placeholder="Немецкое слово" required />
    <input type="text" name="ru" placeholder="Перевод" required />
    <button type="submit">Добавить</button>
  </form>

  <h1>Тренировка</h1>
  <div id="train">
    <p id="question">Нажми «Начать тренировку»</p>
    <input id="answer" placeholder="Перевод" style="display:none;" />
    <p id="feedback"></p>
    <p id="interval"></p>
    <button id="start">Начать тренировку</button>
  </div>

  <hr />

  <h1>Текущие слова</h1>
  <table>
    <thead>
      <tr>
        <th>DE</th><th>RU</th><th>DE→RU</th><th>RU→DE</th>
      </tr>
    </thead>
    <tbody id="tableBody"></tbody>
  </table>
  <p><button id="reset">Сбросить статистику</button></p>

  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <script>

    const socket = io();
    let uiState = { version: 2, mode: "idle", timestamp: null };
    let lastRender = 0;

    function broadcastState(updates={}) {
      uiState = { ...uiState, ...updates, timestamp: new Date().toISOString() };
      socket.emit("client_state", uiState);
    }

    socket.on("state_sync", (msg) => {
      if (msg.type === "data") {
        words = msg.state.words || [];
        renderTable(words);
        return;
      }
      const state = msg.state;
      if (state.version !== 2) { socket.emit("request_full_state"); return; }
      const t = Date.parse(state.timestamp);
      if (t <= lastRender) return;
      lastRender = t;
      if (state && state.mode) renderUI(state);
    });

    socket.on("connect", () => socket.emit("request_full_state"));

    // --- persistent JWT using IndexedDB ---
    const DB_NAME = 'wordsAuthDB', STORE_NAME = 'tokens';

    function openDB() {
      return new Promise((res, rej) => {
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = () => req.result.createObjectStore(STORE_NAME);
        req.onsuccess = () => res(req.result);
        req.onerror = () => rej(req.error);
      });
    }

    async function idbSet(key, val) {
      try {
        const db = await openDB();
        return await new Promise((res, rej) => {
          const tx = db.transaction(STORE_NAME, 'readwrite');
          const store = tx.objectStore(STORE_NAME);
          store.put(val, key);
          tx.oncomplete = () => { db.close(); res(); };
          tx.onerror = () => { db.close(); rej(tx.error); };
        });
      } catch(e) {
        console.error('[idbSet] outer error', e);
      }
    }

    async function idbGet(key) {
      const db = await openDB();
      return new Promise((res, rej) => {
        const tx = db.transaction(STORE_NAME, 'readonly');
        const req = tx.objectStore(STORE_NAME).get(key);
        req.onsuccess = () => res(req.result);
        req.onerror = () => rej(req.error);
      });
    }

    async function idbDel(key) {
      const db = await openDB();
      return new Promise((res, rej) => {
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        store.delete(key);
        tx.oncomplete = () => res();
        tx.onerror = () => rej(tx.error);
      });
    }

    const _ls = window.localStorage;
    const _origSet = _ls.setItem.bind(_ls);
    const _origGet = _ls.getItem.bind(_ls);
    const _origRem = _ls.removeItem.bind(_ls);

    // override localStorage for 'jwt'
    localStorage.setItem = async (k,v)=>{
      if (k==='jwt'){
        try{ await idbSet(k,v); window._cachedJWT=v; } 
        catch(e){ console.error('[idbSet]', e); }
        return;
      }
      _origSet(k,v);
    };
    localStorage.getItem = async (k)=>{
      if (k==='jwt') return window._cachedJWT ?? await idbGet(k) ?? null;
      return _origGet(k);
    };
    localStorage.removeItem = (k)=>{
      if (k==='jwt'){ window._cachedJWT=undefined; return idbDel(k); }
      return _origRem(k);
    };

    // ---------- auth ----------

    async function safeFetch(url, options={}) {
      try {
        const token = await localStorage.getItem('jwt');
        const headers = {'Content-Type': 'application/json', ...(options.headers || {})};
        if (token) headers['Authorization'] = `Bearer ${token}`;
        const r = await fetch(url, {...options, headers});
        if (r.status === 401) {
          // авто-logout
          await fetch('/api/logout');
          document.getElementById('auth').style.display = 'block';
          document.getElementById('loggedIn').style.display = 'none';
          document.getElementById('authStatus').textContent = 'Сессия истекла, войдите снова.';
          document.getElementById('authStatus').style.color = 'red';
          // очистка интерфейса
          document.getElementById('tableBody').innerHTML = '';
          document.getElementById('question').textContent = 'Нажми «Начать тренировку»';
          document.getElementById('interval').textContent = '';
          document.getElementById('feedback').textContent = '';
          words = [];
          current = null;
          clearInterval(pauseTimer);
          throw new Error('401 Unauthorized');
        }
        return r;
      } catch (e) {
        console.error('[safeFetch] error', e);
        throw e;
      }
    }

    async function apiCall(url, body){
      const r = await fetch(url,{
        method:'POST',
        headers:{'Content-Type':'application/json'},
        credentials:'include',
        body:JSON.stringify(body)
      });
      const text = await r.text();
      try {
        const json = JSON.parse(text);
        return json;
      } catch(e) {
        return {status:'error', message:'invalid JSON', raw:text};
      }
    }

    document.getElementById('register').onclick = async ()=>{
      const email=emailInput.value.trim(), password=pwInput.value.trim();
      if (!email || !password) {
        const msg = document.getElementById('authStatus');
        msg.textContent = 'Введите email и пароль.';
        msg.style.color = 'red';
        return;
      }
      const d = await apiCall('/api/register',{email,password});
      const msg = document.getElementById('authStatus');
      if(d.status==='ok'){ msg.textContent='Регистрация успешна! Теперь войдите.'; msg.style.color='green'; }
      else{ msg.textContent='Пользователь уже существует.'; msg.style.color='red'; }
    };

    document.getElementById('login').onclick = async ()=>{
      const email=emailInput.value.trim(), password=pwInput.value.trim();
      if (!email || !password) {
        const msg = document.getElementById('authStatus');
        msg.textContent = 'Введите email и пароль.';
        msg.style.color = 'red';
        return;
      }
      const d = await apiCall('/api/login',{email,password});
      const msg = document.getElementById('authStatus');
      if(d.status==='ok'){
        msg.textContent='Вход выполнен'; msg.style.color='green';
        await localStorage.setItem('jwt', d.token);
        const resp = await safeFetch('/api/words');
        try {
          if (!resp.ok) {
            msg.textContent='Ошибка сессии, попробуйте снова.'; msg.style.color='red';
            return;
          }
          const data = await resp.json();
          renderTable(data);
        } catch(e) {
          console.error('[login] error', e)
        }
        document.getElementById('auth').style.display='none';
        document.getElementById('loggedIn').style.display='block';
        document.getElementById('userEmail').textContent=email;

        startBtn.textContent = 'Начать тренировку';
        q.textContent = 'Нажми «Начать тренировку»';
        a.style.display = 'none';
        feedback.textContent = '';
        intElem.textContent = '';
      } else { msg.textContent='Неверные данные.'; msg.style.color='red'; }
    };

    document.getElementById('logout').onclick = ()=>{
      fetch('/api/logout');
      localStorage.removeItem('jwt');
      document.getElementById('loggedIn').style.display='none';
      document.getElementById('auth').style.display='block';
      document.getElementById('authStatus').textContent='Вы вышли.';
      // очистка интерфейса:
      document.getElementById('tableBody').innerHTML = '';
      document.getElementById('question').textContent = 'Нажми «Начать тренировку»';
      document.getElementById('interval').textContent = '';
      document.getElementById('feedback').textContent = '';
      words = [];
      current = null;
      clearInterval(pauseTimer);
    };
    const emailInput=document.getElementById('email');
    const pwInput=document.getElementById('password');


    // ---------- helpers ----------
    const DEBUG = true;
    const log = (...a) => DEBUG && console.debug('[WORDS]', ...a);
    let mode = 'idle'; // 'idle' | 'ask' | 'check' | 'paused'
    let pauseTimer = null;
    let intervalsHours = [];
    fetch('/api/intervals').then(r=>r.json()).then(arr => intervalsHours = arr);

    function humanInterval(i){
      const h = intervalsHours[i] ?? 0;
      const factor = 1;
      const adjH = h * factor;
      if (adjH < 1)  return `${Math.round(adjH*60)} мин`;
      if (adjH < 24) return `${adjH} ч`;
      return `${Math.round(adjH/24)} дн`;
    }

    const UI_TEXT = {
      paused: (timeLeft) =>
        timeLeft ? `Все слова на паузе. Следующее слово через ${timeLeft}` : "Все слова на паузе…",

      ask: {
        text: (word, reverse) => `Переведи: ${reverse ? word.ru : word.de}`,
        btn: "Проверить"
      },

      check: {
        correct: "✅ Верно",
        wrong: "❌ Ошибка",
        nextBtn: "Следующее слово",
        nextInfo: "Следующее слово готово.",
        wordLabel: (w, reverse) => `Перевод слова: ${reverse ? w.ru : w.de}`
      },

      empty: "Добавь слова, чтобы начать тренировку."
    };

    // ---------- state ----------
    let words = [];
    let current, reverse;

    // ---------- data fetchers ----------
    async function loadWords(){
      const r = await safeFetch('/api/words');
      words = await r.json();
    }

    async function updateTable(){
      const r = await safeFetch('/api/words');
      const data = await r.json();
      words = data; // синхронизируем кэш
      const body = document.getElementById('tableBody');
      body.innerHTML = '';
      data.forEach(w => {
        const row = document.createElement("tr");
        const c1 = document.createElement("td");
        c1.textContent = w.de;
        const c2 = document.createElement("td");
        c2.textContent = w.ru;
        const c3 = document.createElement("td");
        c3.textContent = `${w.interval_de_ru} (${humanInterval(w.interval_de_ru)})`;
        const c4 = document.createElement("td");
        c4.textContent = `${w.interval_ru_de} (${humanInterval(w.interval_ru_de)})`;
        if (w.block_until_ru_de && new Date(w.block_until_ru_de) > new Date()) {
          const left = Math.ceil((new Date(w.block_until_ru_de) - new Date()) / 60000);
          c4.textContent += ` ⏸ ${left} мин`;
        }
        row.append(c1, c2, c3, c4);
        body.appendChild(row);
      });
    }

    function renderUI(s) {
      if (!s || !s.mode) return;
      mode = s.mode;

      // Сброс интерфейса перед применением нового состояния
      q.textContent = "";
      a.value = "";
      feedback.textContent = "";
      intElem.textContent = "";

      if (!words.length) {
        q.textContent = UI_TEXT.empty;
        startBtn.style.display = "none";
        return;
      }
      if (s.mode === "ask") {
        const cur = words.find(w => w.id === s.currentId);
        if (!cur) return;
        q.textContent = UI_TEXT.ask.text(cur, s.reverse);
        a.style.display = "inline";
        startBtn.style.display = "inline";
        startBtn.textContent = UI_TEXT.ask.btn;
        startBtn.disabled = false;
        a.focus();
      } else if (s.mode === "check") {
        const cur = words.find(w => w.id === s.currentId);
        feedback.textContent = UI_TEXT.check[s.feedbackType];
        if (cur) {
          if (s.feedbackType === "correct") {
            q.textContent = `${cur.de} → ${cur.ru}`;
          } else if (s.feedbackType === "wrong" && s.lastAnswer) {
            q.textContent = `${cur.de} → ${s.lastAnswer} ❌ (правильно: ${cur.ru})`;
          } else {
            q.textContent = UI_TEXT.check.wordLabel(cur, s.reverse);
          }
        }
        startBtn.textContent = UI_TEXT.check.nextBtn;
        startBtn.focus();
        intElem.textContent = UI_TEXT.check.nextInfo;
        a.style.display = "none";
        startBtn.style.display = "inline";
        startBtn.disabled = false;
      } else if (s.mode === "paused") {
        let timeLeft = "";
        if (s.nextTime) {
          const diff = new Date(s.nextTime) - new Date();
          const m = Math.floor(diff / 60000),
                sec = Math.floor((diff / 1000) % 60);
          timeLeft = `${m} мин ${sec} сек.`;
        }
        q.textContent = UI_TEXT.paused(timeLeft);
        startBtn.style.display = "none";
        a.style.display = "none";
        startBtn.disabled = true;
        if (!pauseTimer && s.nextTime) {
          function tick() {
            const diff = new Date(s.nextTime) - new Date();
            if (diff <= 0) { clearInterval(pauseTimer); pauseTimer = null; pickWord(); return; }
            const m = Math.floor(diff/60000), sec = Math.floor(diff/1000)%60;
            q.textContent = `Все слова на паузе. Следующее слово через ${m} мин ${sec} сек.`;
          }
          tick();
          pauseTimer = setInterval(tick, 1000);
        }
      }
    }

    function renderTable(data) {
      words = data;
      const body = document.getElementById("tableBody");
      body.innerHTML = "";
      data.forEach(w => {
        const row = document.createElement("tr");
        const c1 = document.createElement("td");
        c1.textContent = w.de;
        const c2 = document.createElement("td");
        c2.textContent = w.ru;
        const c3 = document.createElement("td");
        c3.textContent = `${w.interval_de_ru} (${humanInterval(w.interval_de_ru)})`;
        const c4 = document.createElement("td");
        c4.textContent = `${w.interval_ru_de} (${humanInterval(w.interval_ru_de)})`;
        if (w.block_until_ru_de && new Date(w.block_until_ru_de) > new Date()) {
          const left = Math.ceil((new Date(w.block_until_ru_de) - new Date()) / 60000);
          c4.textContent += ` ⏸ ${left} мин`;
        }
        row.append(c1, c2, c3, c4);
        body.appendChild(row);
      });
    }

    // ---------- add word form ----------
    document.getElementById('addForm').addEventListener('submit', async (e)=>{
      e.preventDefault();
      const f = e.target;
      const body = { de: f.de.value.trim(), ru: f.ru.value.trim() };
      if (!body.de || !body.ru) return;
      await safeFetch('/api/add_word', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(body)
      });
      f.reset();
      await updateTable();
      await loadWords();
      startBtn.textContent = 'Проверить';
      feedback.textContent = '';
      intElem.textContent = '';
      pickWord();
    });

    // ---------- training ----------
    const q = document.getElementById('question');
    const a = document.getElementById('answer');
    const startBtn = document.getElementById('start');
    const feedback = document.getElementById('feedback');
    const intElem = document.getElementById('interval');

    function pickWord(){
      log('pick:start');
      if (pauseTimer){ clearInterval(pauseTimer); pauseTimer = null; }
      startBtn.style.display = "inline";
      const now = new Date();
      const cards = [];
      for (const w of words){
        const now = new Date();
        const deruReady = new Date(w.next_de_ru) < now;
        const blockActive = w.block_until_ru_de && new Date(w.block_until_ru_de) > now;
        const rudeReady = !blockActive && new Date(w.next_ru_de) < now;
        if (deruReady) {                 // приоритет DE→RU
          cards.push({ w, reverse:false });
          continue;                      // не добавляем RU→DE для этого же слова
        }
        if (rudeReady) {
          cards.push({ w, reverse:true });
        }
      }
      // если все слова на паузе из-за блоков — найдём ближайшее окончание блока
      if (cards.length === 0) {
        const future = words
          .flatMap(w => [w.next_de_ru, w.next_ru_de, w.block_until_ru_de])
          .filter(Boolean)
          .map(t => new Date(t))
          .filter(d => d > now)
          .sort((a, b) => a - b);
        if (future.length) {
          const next = future[0];
          const nextTime = next.toISOString();
          mode = 'paused';
          broadcastState({ mode, nextTime });
          renderUI({ mode, nextTime });
          log('pick:pause:next', { next });
          return;
        }
      }
      log('pick:cards', cards.length);

      if (!cards.length){
        const nextTimes = words
          .map(w => Math.min(new Date(w.next_de_ru), new Date(w.next_ru_de)))
          .filter(t => t > new Date())
          .sort((a,b)=>a-b);
        const next = nextTimes[0];
        const nextTime = next ? new Date(next).toISOString() : null;
        mode = 'paused';
        broadcastState({ mode, nextTime });
        renderUI({ mode, nextTime });
        log('pick:pause', { hasNext: !!next, next });
        if (!next){
          q.textContent = "Все слова на паузе. Ожидание новых слов…";
          a.style.display = "none";
          startBtn.style.display = "none";
          return;
        }

        function tick(){
          const diff = next - new Date();
          if (diff <= 0){
            log('tick:zero -> autostart');
            clearInterval(pauseTimer); pauseTimer = null;
            q.textContent = "Время истекло, загружаем слова...";
            startBtn.textContent = 'Следующее слово'; // сброс кнопки
            loadWords().then(()=>controller());
            return;
          }
          const m = Math.floor(diff/60000);
          const s = Math.floor(diff/1000) % 60;
          q.textContent = `Все слова на паузе. Следующее слово через ${m} мин ${s} сек.`;
        }
        tick();
        pauseTimer = setInterval(tick, 1000);

        a.style.display = "none";
        startBtn.style.display = "none";
        return;
      }

      const pick = cards[Math.floor(Math.random()*cards.length)];
      current = pick.w;
      reverse = pick.reverse;
      mode = 'ask';
      log('pick:show', { id: current.id, word: current.de, reverse });

      q.textContent = UI_TEXT.ask.text(current, reverse);
      a.style.display = "inline";
      a.value = "";
      a.focus();
      broadcastState({ mode, currentId: current.id, reverse });
    }

    async function processAnswer(){
      const user = a.value.trim().toLowerCase();
      const correct = reverse ? user === current.de.toLowerCase()
                              : user === current.ru.toLowerCase();
      log('answer', { id: current.id, reverse, user, correct });

      feedback.style.color = correct ? 'green' : 'red';
      mode = 'check';

      startBtn.disabled = true;

      const resp = await safeFetch('/api/result?fast=0', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: current.id, correct, reverse })
      });

      const data = await resp.json();
      const w = data.updated;

      const key = reverse ? 'interval_ru_de' : 'interval_de_ru';
      const h = intervalsHours[w[key]];
      const text = (h < 1) ? `${Math.round(h*60)} минут`
                 : (h < 24) ? `${h} часов`
                 : `${Math.round(h/24)} дней`;

      await updateTable();
      log('answer:updated');

      startBtn.disabled = false;
      broadcastState({
        mode: "check",
        feedbackType: correct ? "correct" : "wrong",
        nextText: `Следующая встреча этого слова через ${text}.`,
        nextBtnText: startBtn.textContent,
        currentId: current.id,
        reverse
      });
    }

    async function controller(){
      log('controller', { mode, btn: startBtn.textContent, words: words.length });
      if (!words.length) await loadWords();

      if (mode === 'idle' || mode === 'check') {
        startBtn.textContent = 'Проверить';
        feedback.textContent = '';
        intElem.textContent = '';
        pickWord();
        return;
      }

      if (mode === 'ask') {
        await processAnswer();
        return;
      }

      if (mode === 'next') {
        pickWord();
        if (current) {
          broadcastState({
            mode: "ask",
            currentId: current.id,
            reverse
          });
        } else {
          broadcastState({ mode: "paused" });
        }
        return;
      }

    }

    startBtn.addEventListener('click', controller);

    // Enter = клик по кнопке, но только если не ждём сервер
    a.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' && !startBtn.disabled){
        e.preventDefault();
        controller();
      }
    });

    // ---------- reset ----------
    document.getElementById('reset').addEventListener('click', async ()=>{
      if (!confirm('Сбросить всю статистику?')) return;
      await safeFetch('/api/reset', { method: 'POST' });
      feedback.textContent = '';
      intElem.textContent = '';
      await updateTable();
      mode = "idle";
      pickWord();
    });

    // рендер таблицы
    (async () => {
      try {
        const saved = await localStorage.getItem('jwt');
        if (saved) {
          const resp = await fetch('/api/refresh_token', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({token: saved})
          });
          const d = await resp.json();
          if (d.status === 'ok') {
            localStorage.setItem('jwt', d.token);
            document.getElementById('auth').style.display = 'none';
            document.getElementById('loggedIn').style.display = 'block';
            document.getElementById('userEmail').textContent = 'auto-login';
          }
        }
        const r = await safeFetch('/api/words');
        if (r.ok) {
          // пользователь залогинен — показываем всё
          const d = await r.json();
          words = d;
          renderTable(d)
          document.getElementById('auth').style.display = 'none';
          document.getElementById('loggedIn').style.display = 'block';
          document.getElementById('userEmail').textContent = d.length ? d[0].user_id : '';
          if (!d.length) {
            document.getElementById('auth').style.display = 'block';
            document.getElementById('loggedIn').style.display = 'none';
          }
        }
      } catch {
        // не залогинен — показываем только форму
        document.getElementById('auth').style.display = 'block';
        document.getElementById('loggedIn').style.display = 'none';
        document.getElementById('tableBody').innerHTML = '';
      }
    })();

  </script>
</body>
</html>
